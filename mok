#!/home/ivan/bin/perl

use strict;
use warnings;
use Chemistry::Mol;
use Chemistry::File ':auto';
use Chemistry::Pattern;
use Getopt::Std;


# parse_code is at the top of the file to avoid the evaled code block having
# access to file-scoped lexicals
sub parse_code {
    my ($code) = @_;
    my ($patt_str, $patt_opts, $block) = $code =~ m<^\s*
        (?:
            /(.*?)/([goOpP]*)\s*  # pattern
        )?
        {(.*)}          # code block
    >sxg;
    $block ||= $code;

    #print "code=$code\npatt=$patt_str\nblock=$block\n"; exit;
    my $sub = eval <<END;
        package Mok::UserCode;
        no strict;
        no warnings;
        sub {
            my (\$mol, \$file, \$match) = \@_;
            $block;
        }
END
    die $@ if $@;

    my $patt;
    if ($patt_str) {
        $patt = Chemistry::Pattern->parse($patt_str, format => 'smiles');
        $patt->attr(global => 1) if $patt_opts =~ /g/;
        $patt->options(overlap => 1) if $patt_opts =~ /o/;
        $patt->options(overlap => 0) if $patt_opts =~ /O/;
        $patt->options(permute => 1) if $patt_opts =~ /p/;
        $patt->options(permute => 0) if $patt_opts =~ /P/;
    } 
    ($sub, $patt);
}

my %opt;
getopts('f:t:hv', \%opt);
usage() if $opt{h};

my $code;

if ($opt{f}) {
    open F, "< $opt{f}" or die "Couldn't read $opt{f}\n";
    {local undef $/; $code = <F>;}
    close F;
} else {
    $code = shift || usage();
}

my ($code_block, $patt) = parse_code($code);

for my $file (@ARGV) {
    my (@mols) = Chemistry::Mol->read($file, format => $opt{t});
    for my $mol (@mols) {
        if ($patt) {
            while ($patt->match($mol)) {
                $code_block->($mol, $file, $patt);
                last unless $patt->attr('global');
            }
        } else {
            $code_block->($mol, $file, $patt);
        }
    }
}

sub usage {
    print <<EOF;
Usage: $0 [OPTION]...  'CODE' FILE...
Read each molecular file and run CODE on each. Options:
    -h          this help
    -t TYPE     assume that every file has the specified TYPE
    -f FILE     run the code from FILE instead of the command line
EOF
    exit;
}

package Mok::UserCode;
use Chemistry::Atom ':all';

__END__

=head1 TITLE

mok - molawk - an awk for molecules

=head1 SYNOPSIS

    mok [OPTION]...  'CODE' FILE...   

=head1 DESCRIPTION

The function of mok is:

To read all the molecules found in the files that are
given in the command line.

Loop, for each molecule execute the CODE that is given. The code is in Perl,
but it has at its disposal all the methods of the PerlMol toolkit.

This program is inspired by: 

The awk(1) programming language by Aho, Kernighan, and  Weinberger.
The SMARTS molecular pattern description language.
The Perl programming language by Larry Wall.

=head1 OPTIONS

=over

=item -f FILE

run the code from FILE instead of the command line

=item -h  

print usage information and exit

=item -t TYPE     

assume that every file has the specified TYPE. Available types depend on
which Chemistry::File modules are installed, but currently available types
include mdl, sdf, smiles, formula, mopac, pdb.

=back

=head1 EXAMPLES

    mok '/C(=O)OC/{ printf "$file: %s (%s)\n", 
        $mol->name, $mol->formula }' *.mol

Finds esters among *.mol; prints the filename, molecule name, and formula.

=head1 SEE ALSO

awk(1)

=head1 AUTHOR

Ivan Tubert E<lt>itub@cpan.orgE<gt>

=head1 COPYRIGHT

Copyright (c) 2003 Ivan Tubert. All rights reserved. This program is free
software; you can redistribute it and/or modify it under the same terms as
Perl itself.

=cut

